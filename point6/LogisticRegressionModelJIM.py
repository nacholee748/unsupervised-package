# Now, apply dimensionality reduction using all your algorithms to train the model with only 2 features per
# image.
# - Plot the 2 new features generated by your algorithm
# - Does this somehow impact the performance of your model?

import numpy as np
import matplotlib.pyplot as plt
from unsupervised_jim import PCA, SVD, TSNE
from sklearn.datasets import fetch_openml
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from joblib import dump,load

class LogisticRegressionModelJIM:

    def __init__(self):
        self.x_train = None
        self.x_test = None
        self.y_train = None
        self.y_test = None
        self.model_trained = None

    def get_nmist_data_splited(self,split_size=0.75):
        mnist = fetch_openml('mnist_784')
        self.x_train, self.x_test, self.y_train, self.y_test = train_test_split(mnist.data, mnist.target, train_size=split_size, random_state=42)
        return self.x_train, self.x_test, self.y_train, self.y_test

    def data_standarization(self,x_train,y_train):
        scaler = StandardScaler()
        x_scaled = scaler.fit_transform(x_train)
        y_scaled = y_train.astype(int)

        return x_scaled,y_scaled


    def train_model(self,x_train,y_train):
        model = LogisticRegression(random_state=42, max_iter=1000)
        model.fit(x_train, y_train)
        self.model_trained = dump(model, "model.joblib")

        return {"message":"Model trained!!"}

    def test_model(self,x_test,y_test):
        accuracy = self.model_trained.score(x_test, y_test)
        print(f"La precisi√≥n del modelo es: {accuracy:.2f}")

    def get_svd(self,x_data,n_components=5):
        svd = SVD(n_components=n_components)
        svd_transfored = svd.fit_transform(x_data)
        return svd_transfored

    def get_tsne(self,x_data,components=5):
        TSNE = TSNE(n_components=components)
        tsne_transformed = TSNE.fit_transform(x_data)
        return tsne_transformed

    def get_pca(self,x_data,n_components=5):
        pca = PCA(n_components=n_components)
        pca.fit(x_data)
        pca_transformed = pca.fit_transform(x_data)

        return pca_transformed

    def predict(self,nmist_img):
        model = load(self.model_trained)
        predicted = model.predict(nmist_img)

        return predicted

